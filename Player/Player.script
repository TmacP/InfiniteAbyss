-- player.script

-- get screen swimWidth
local screen_width = (sys.get_config("display.width") / 2)
local center_x = sys.get_config("display.width") / 2
local center_y = sys.get_config("display.height") / 2

local speed = 150      -- Adjust the speed as needed
local gravity = -30    -- Adjust the gravity as needed
local swimHeight = 90 -- The max height one touch can swim up
local swimWidth = 90



local vertical_speed 
local horizontal_speed 

-- debug flags
local debugMode = false
local debugCollision = false
local debugAngle = false

function init(self)
	msg.post(".", "acquire_input_focus")  -- Acquire input focus for the script
	self.currentHeight = 0  -- Initialize the current height
	self.currentWidth = 0 -- Initialize the current width
	self.facing = 0 -- direction player is facing 0 is right 1 is left
	-- correction vector for collision
	self.correction = vmath.vector3()
end

function update(self, dt)
	-- Apply gravity continuously to make the player sink when not touched
	go.set_position(vmath.vector3(go.get_position().x, go.get_position().y + gravity * dt, 0))

	-- Move the player up if the touch flag is true and the current height is below swimHeight
	if self.is_touched and self.currentHeight < swimHeight then
		local deltaY = math.min(vertical_speed * dt, swimHeight - self.currentHeight)
		go.set_position(vmath.vector3(go.get_position().x, go.get_position().y + deltaY, 0))
		self.currentHeight = self.currentHeight + deltaY
	end

	-- move the player in the direction they are facing
	if self.is_touched and self.facing == 1  and self.currentWidth < swimWidth then
		local deltaX = math.min(horizontal_speed * dt, swimWidth - self.currentWidth)
		go.set_position(vmath.vector3(go.get_position().x - deltaX, go.get_position().y, 0))
		self.currentWidth = self.currentWidth + deltaX
	elseif self.is_touched and self.facing == 0 and self.currentWidth < swimWidth then
		local deltaX = math.min(horizontal_speed * dt, swimWidth - self.currentWidth)
		go.set_position(vmath.vector3(go.get_position().x + deltaX, go.get_position().y, 0))
		self.currentWidth = self.currentWidth + deltaX
	end
	
	
	-- reset correction
	self.correction = vmath.vector3()
end


function on_input(self, action_id, action)
	if action_id == hash("touch") then
		if action.pressed then
			-- When the screen is touched, set a flag to move the player up
			self.is_touched = true
			-- Save the initial touch position for comparison
			self.touchStartPosition = action.x


			-- Calculate the angle between touch position and center of the screen

			local touch_angle = math.atan2(action.y - center_y, action.x - center_x)

			-- Adjust speed and direction based on the touch angle
			vertical_speed = math.sin(touch_angle) * speed
			horizontal_speed = math.abs(math.cos(touch_angle) * speed)

			-- DEBUG
			if debugAngle then
				print("Touch Angle: " .. touch_angle)
				print("Vertical Speed: " .. vertical_speed)
				print("Horizontal Speed: " .. horizontal_speed)
			end
			-- DEBUG end



			
			-- DEBUG
			-- Print the touch coordinates
			if debugMode then print("Touch coordinates: x=" .. action.x) end
			-- Print the coordinates of the player game object
			if debugMode then print("Player coordinates: x=" .. go.get_position().x) end
			-- Print direction
			if debugMode then
				local touchDirection = (action.x < go.get_position().x) and "Left of player" or "Right of player"
				print("Touch is " .. touchDirection)
			end
			-- DEBUG end

			-- Flip the sprite horizontal based on touch
			local position = go.get_position()
			if action.x < screen_width then
				sprite.set_hflip("#sprite", true)
				self.facing = 1
				if debugMode then print("self facing left" .. self.facing) end
			else
				sprite.set_hflip("#sprite", false)
				self.facing = 0
				if debugMode then print("self facing right" .. self.facing) end
			end
			
		elseif action.released then
			-- When the touch is released, set the flag to false and reset current height
			self.is_touched = false
			self.currentHeight = 0
			self.currentWidth = 0
			self.touchStartPosition = nil
			self.touchDirection = nil
		end
	end
end


function on_message(self, message_id, message, sender)
	if debugCollision then print("Collision on_message") end
	-- Handle collision
	if message_id == hash("contact_point_response") then
		-- Get the info needed to move out of collision. We might
		-- get several contact points back and have to calculate
		-- how to move out of all of them by accumulating a
		-- correction vector for this frame:
		if message.distance > 0 then
			-- First, project the accumulated correction onto
			-- the penetration vector
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				-- Only care for projections that does not overshoot.
				local comp = (message.distance - message.distance * proj) * message.normal
				-- Apply compensation
				go.set_position(go.get_position() + comp)
				-- Accumulate correction done
				self.correction = self.correction + comp
			end
		end
	end
end